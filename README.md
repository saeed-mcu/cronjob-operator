# cronjob-operator

## Technical requirements
* go version 1.16+
* An `kubebuilder` binary installed locally
* Make sure your user is authorized with cluster-admin permissions.

## Step 1 : Setting up your project

initialize a boilerplate project structure with the following:

```bash
# we'll use a domain of tutorial.kubebuilder.io
# so all API groups will be <group>.tutorial.kubebuilder.io
kubebuilder init --domain tutorial.kubebuilder.io --repo github.com/saeed-mcu/cronjob-operator
```

## Step 2 : Defining an API
```bash
kubebuilder create api --group batch --version v1 --kind CronJob
```
Press y for “Create Resource” and “Create Controller”.

`CronJob` is our root type, and describes the `CronJob` kind.
Like all Kubernetes objects, it contains `TypeMeta` (which describes API version and Kind), and also contains `ObjectMeta`,
which holds things like name, namespace, and labels.
`CronJobList` is simply a container for multiple CronJobs.
It’s the Kind used in bulk operations, like LIST.

In general, we never modify either of these – all modifications go in either Spec or Status.
We define types for the `desired state (Spec)` and `observed state(Status)` of our Kind.

That little `+kubebuilder:object:root` comment is called a marker.
This particular one tells the object generator that this type represents a Kind.
Then, the object generator generates an implementation of the runtime.Object interface for us,
which is the standard interface that all types representing Kinds must implement.

Finally, we add the Go types to the API group. This allows us to add the types in this API group to any Scheme.
```go
func init() {
    SchemeBuilder.Register(&CronJob{}, &CronJobList{})
}
```
## Step 3 : Designing an API
All serialized fields must be **camelCase**, so we use JSON struct tags to specify this.
We can also use the `omitempty` struct tag to mark that a field should be omitted from serialization when empty.

Additional files beyond cronjob_types.go:
* `groupversion_info.go` contains common metadata about the group-version
* `zz_generated.deepcopy.go` contains the autogenerated implementation of the aforementioned runtime.Object interface, which marks all of our root types as representing Kinds.

Neither of these files ever needs to be edited.

## Step 4 : Implement Controller
It’s a controller’s job to ensure that, for any given object, the **actual state** of the world matches the **desired state** in the object.
Each controller focuses on one root Kind, but may interact with other Kinds. We call this process __reconciling__.
In controller-runtime, the logic that implements the reconciling for a specific kind is called a __Reconciler__.

Most controllers eventually end up running on the cluster, so they need RBAC permissions, which we specify using controller-tools `RBAC markers`.

Most controllers need a logging handle and a context, so we set them up here.

The `context` is used to allow cancellation of requests, and potentially things like tracing.
It’s the first argument to all client methods.
The Background context is just a basic context without any extra data or timing restrictions.

Controller-runtime uses structured logging through a library called `logr`.
logging works by attaching key-value pairs to a static message.

Finally, we add this reconciler to the manager, so that it gets started when the manager is started.
```go
func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&batchv1.CronJob{}).
        Complete(r)
}
```

All client methods take a `context` (to allow for cancellation) as their first argument, and the object in question as their last
